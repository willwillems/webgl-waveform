<!doctype html>
<html>
    <head>
        <title>Fullscreen Quad with WebGL 2</title>
        <style>
            body {
                margin: 0;
            }
            canvas {
                display: block;
                margin: 50px auto;
            }
        </style>
    </head>
    <body>
        <canvas id="webgl-canvas"></canvas>
        <script type="module">
            /** @type {HTMLCanvasElement} */
            const canvas = document.getElementById("webgl-canvas");
            /** @type {WebGL2RenderingContext} */
            const gl = canvas.getContext("webgl2");

            canvas.width = 512;
            canvas.height = 200;

            // Vertex Shader Source
            const vertexShaderSource = `#version 300 es
                in vec2 a_position;
                in vec2 a_uv;
                out vec2 vUv;
                void main() {
                    gl_Position = vec4(a_position, 0.0, 1.0);
                    vUv = a_uv;
                }
            `;

            // Fragment Shader Source
            const fragmentShaderSource = `#version 300 es
                precision highp float;

                in vec2 vUv; // uv gets passsed along from the original buffer to the fragment shader
                out vec4 outColor;

                uniform sampler2D uTexture; // this is the float 32 texture we're passing in
                // Below units are in samples count, can be in other units (like pixels) as well
                uniform int uWindow; // this is the window size
                uniform int uSampleWidth;
                uniform int uSampleHeight;
                uniform int uOffset; // this is the offset

                uniform int uHeight; // this is the height in px
                uniform int uWidth; // this is the width in px

                // float smoothSample(vec2 uv, float e)
                // {
                //     // return texture(uTexture, uv).x;

                //     float sum = 0.0;
                //     for (float i = -1.0; i <= 1.0; i += 1.0) {
                //         sum += texture(uTexture, uv - vec2(e * i * 0.5, 0.0)).x;
                //     }
                //     return sum / 3.0;
                // }

                float interStep(float min, float max, float value)
                {
                    return step(min, value) * step(value, max);
                }

                void main() {

                    float v = 0.0;

                    // mapping for sample range
                    int bucketSize = uWindow / uWidth;
                    int start = uOffset + int(floor(gl_FragCoord.x)) * bucketSize;

                    // mapping for sample amplitude range
                    float stepSize = 2.0 / float(uHeight);
                    float min = vUv.y * 2.0 - 1.0;
                    float max = min + stepSize;

                    // vec2 ccoord = vec2(float(start % uSampleWidth) / float(uSampleWidth), float(start / uSampleWidth) / float(uSampleHeight));

                    for (int i = 0; i < bucketSize; i += 1) {
                        int pos = start + i;
                        ivec2 coord = ivec2(pos % uSampleWidth, pos / uSampleWidth);
                        float value = texelFetch(uTexture, coord, 0).r;
                        // todo: instead check if pos.x is between value cur and prev
                        v +=  interStep(min, max, value) / float(bucketSize) *20.0;
                    }

                    outColor = vec4(vec3(v), 1.);
                }
            `;

            // Compile Shader Function
            function compileShader(type, source) {
                const shader = gl.createShader(type);
                gl.shaderSource(shader, source);
                gl.compileShader(shader);
                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                    console.error(
                        "Shader compile error:",
                        gl.getShaderInfoLog(shader),
                    );
                    gl.deleteShader(shader);
                    return null;
                }
                return shader;
            }

            // Create and Compile Shaders
            const vertexShader = compileShader(
                gl.VERTEX_SHADER,
                vertexShaderSource,
            );
            const fragmentShader = compileShader(
                gl.FRAGMENT_SHADER,
                fragmentShaderSource,
            );

            // Create and Link Program
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error(
                    "Program link error:",
                    gl.getProgramInfoLog(program),
                );
                gl.deleteProgram(program);
            }
            gl.useProgram(program);

            // Define Quad Vertices
            const vertices = new Float32Array([
                -1, -1, 0, 0, 1, -1, 1, 0, -1, 1, 0, 1, 1, 1, 1, 1,
            ]);

            // Create and Bind Vertex Array
            const vertexArray = gl.createVertexArray();
            gl.bindVertexArray(vertexArray);

            // Create and Bind Buffer
            const vertexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

            // Get Attribute Locations
            const positionLocation = gl.getAttribLocation(
                program,
                "a_position",
            );
            const uvLocation = gl.getAttribLocation(program, "a_uv");

            // Setup Position Attribute
            gl.enableVertexAttribArray(positionLocation);
            gl.vertexAttribPointer(
                positionLocation,
                2,
                gl.FLOAT,
                false,
                4 * 4,
                0,
            );

            // Setup UV Attribute
            gl.enableVertexAttribArray(uvLocation);
            gl.vertexAttribPointer(
                uvLocation,
                2,
                gl.FLOAT,
                false,
                4 * 4,
                2 * 4,
            );

            // const numSamples = 2048;
            // const cycles = 10; // number of cycles
            // const frequency = 0.2 * Math.PI * cycles; // total angle for the specified number of cycles

            // // Create and Bind Texture
            // const samples = new Float32Array(numSamples);
            // for (let i = 0; i < numSamples; i++) {
            //     samples[i] = Math.sin((i * frequency) / numSamples);
            // }

            const audioCtx = new window.AudioContext();
            // load audio file ./audio.mp3
            const resp = await fetch("https://archive.org/download/daft-punk-homework/A2.%20WDPK%2083.7%20FM.mp3");
            const arrayBuffer = await resp.arrayBuffer();
            const audioBuffer = await audioCtx.decodeAudioData(arrayBuffer);
            const channelData = audioBuffer.getChannelData(0);

            const numSamples = channelData.length;

            const textureWidth = gl.getParameter(gl.MAX_TEXTURE_SIZE);
            const textureHeight = Math.ceil(numSamples / textureWidth);

            const sampleBufferSize = textureWidth * textureHeight;
            const samples = new Float32Array(sampleBufferSize); // texture needs to be filled with data

            for (let i = 0; i < sampleBufferSize; i++) {
                samples[i] = channelData[i] ?? 0;
            }

            // DOWNSAMPLING ALGO THAT DOESN'T WORK TOO WELL RN

            // for (let i = 0; i < numSamples; i += 2) {
            //     const stepSize = 1 / numSamples;

            //     const bucketStart = Math.round(
            //         i * stepSize * channelData.length,
            //     );
            //     const bucketEnd = Math.round(
            //         (i + 1) * stepSize * channelData.length,
            //     );
            //     const slice = channelData.slice(bucketStart, bucketEnd);

            //     const max = Math.max(...slice);
            //     const min = Math.min(...slice);

            //     samples[i] = max;
            //     samples[i + 1] = min;
            // }

            const texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.texImage2D(
                gl.TEXTURE_2D,
                0,
                gl.R16F,
                textureWidth,
                textureHeight,
                0,
                gl.RED,
                gl.FLOAT,
                samples,
            );
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);

            // Set Uniforms
            const textureLocation = gl.getUniformLocation(program, "u_texture");
            gl.uniform1i(textureLocation, 0);

            // Get uniform locations for window and samples
            const windowLocation = gl.getUniformLocation(program, "uWindow");
            const sampleWidthLocation = gl.getUniformLocation(
                program,
                "uSampleWidth",
            );
            const sampleHeightLocation = gl.getUniformLocation(
                program,
                "uSampleHeight",
            );
            const offsetLocation = gl.getUniformLocation(program, "uOffset");

            const widthLocation = gl.getUniformLocation(program, "uWidth");
            const heightLocation = gl.getUniformLocation(program, "uHeight");

            let sampleWindow = 1024; // Render half of the array at a time
            let offset = 256;
            gl.uniform1i(windowLocation, sampleWindow);
            gl.uniform1i(sampleWidthLocation, textureWidth);
            gl.uniform1i(sampleHeightLocation, textureHeight);
            gl.uniform1i(offsetLocation, 256);

            gl.uniform1i(widthLocation, canvas.width);
            gl.uniform1i(heightLocation, canvas.height);

            // Bind Texture Unit
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, texture);

            let direction = 1; // 1 for increasing, -1 for decreasing

            function animate() {
                // Update window value
                offset += direction * 1; // Adjust the speed multiplier as needed
                if (offset > 100024 || offset < 0) {
                    direction *= -1; // Reverse direction
                }
                gl.uniform1i(offsetLocation, offset);
                gl.uniform1i(windowLocation, sampleWindow);

                gl.uniform1i(widthLocation, canvas.width);
                gl.uniform1i(heightLocation, canvas.height);

                // Set Viewport and Draw
                gl.viewport(0, 0, canvas.width, canvas.height);
                gl.clearColor(0, 0, 0, 1);
                gl.clear(gl.COLOR_BUFFER_BIT);
                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

                requestAnimationFrame(animate);
            }

            // Start the animation
            animate();
        </script>
    </body>
</html>
